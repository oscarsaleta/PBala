    |\^/|     Maple 18 (X86 64 LINUX)
._|\|   |/|_. Copyright (c) Maplesoft, a division of Waterloo Maple Inc. 2014
 \  MAPLE  /  All rights reserved. Maple is a trademark of
 <____ ____>  Waterloo Maple Inc.
      |       Type ? for help.
> N:=taskId:
> ii:=[X[1],X[2],X[3]]:
> x0:=[X[4],X[5],X[6]]:
> 
> with(LinearAlgebra):
> read "/home/osr/pvm3/primer/piecewise5.lib":
Error, unable to read `/home/osr/pvm3/primer/piecewise5.lib`
> var:=indets(n0)minus({a,b,r});
                                  var := {n0}

> nul:=[seq(seq(A[j,k-j]=0,j=0..k),k=N+1..5),seq(seq(B[j,k-j]=0,j=0..k),k=N+1..5)];
                                   nul := []

> r:=sqrt(R);
                                         1/2
                                   r := R

> n0:=sort(collect(factor(subs(nul,n0/r^2)),R,factor),R):
Error, recursive assignment
> n1:=sort(collect(factor(subs(nul,n1)),R,factor),R):
> n2:=sort(collect(factor(subs(nul,n2)),R,factor),R):
> ldegree(n0,R);deg0:=degree(n0,R);
                                       0

                                   deg0 := 0

> ldegree(n1,R);deg1:=degree(n1,R);
                                       0

                                   deg1 := 0

> ldegree(n2,R);deg2:=degree(n2,R);
                                       0

                                   deg2 := 0

> var:=[op(indets(n0)minus({a,b,r,R}))];
                                  var := [n0]

> for j from 0 to deg0 do
> eq0[j]:=coeff(n0,R,j)-a0[j];
> od:
> for j from 0 to deg1 do
> eq1[j]:=coeff(n1,R,j)-a1[j];
> od:
> for j from 0 to deg2 do
> eq2[j]:=coeff(n2,R,j)-a2[j];
> od:
> M,Nn:=GenerateMatrix([seq(eq2[k],k=deg2..0,-1),seq(eq1[k],k=deg1..0,-1),seq(eq0[k],k=deg0..0,-1)],var);
                                   [0]  [-n2 + a2[0]]
                                   [ ]  [           ]
                          M, Nn := [0], [-n1 + a1[0]]
                                   [ ]  [           ]
                                   [1]  [   a0[0]   ]

> rowM:=RowDimension(M);
memory used=2.9MB, alloc=40.3MB, time=0.08
                                   rowM := 3

> colM:=ColumnDimension(M);
                                   colM := 1

> Ms:=evalm(ReducedRowEchelonForm(<M|IdentityMatrix(rowM)>)):
> P:=evalm(DeleteColumn(%,1..colM)):
> rr:=Rank(M);
                                    rr := 1

> evalm( P . M . Transpose(convert(var,Matrix))):
> sys:=(convert(evalm((( %-Transpose(P . Nn)))),vector)):
> {seq(sys[k],k=rr+1..rowM)}:
> vars:=indets(%);
                         vars := {n1, n2, a1[0], a2[0]}

> a:=s*(1-t^2)/(1+t^2):
> b:=s*2*t/(1+t^2):
> N0:=unapply(collect(numer(factor(n0)),R,factor),R):
> N1:=unapply(collect(expand(subs(R=R*(s-1)+1,numer(factor(n1)))),R,factor),R):
> N2:=unapply(collect(expand(numer(subs(R=-s/(R-1),numer(factor(n2))))),R,factor),R):
> with(Student[MultivariateCalculus]):
> 
> 
> fer:=proc(ii,x0) local F,ss,M0,M1,M2,ss1,varJ,GEJ;
> F:=[]:
>   if ii[1]<>0 then F:=[N0(x0[1]),seq((D@@k)(N0)(x0[1]),k=1..ii[1]-1)] fi;
>   if ii[2]<>0 then F:=[op(F),N1(x0[2]),seq((D@@k)(N1)(x0[2]),k=1..ii[2]-1)] fi;
>   if ii[3]<>0 then F:=[op(F),N2(x0[3]),seq((D@@k)(N2)(x0[3]),k=1..ii[3]-1)] fi;
> ss:=solve({op(F)},{op(var)});
> M0:=simplify(subs(ss,N0(R))):
> M1:=factor(simplify(subs(ss,N1(R)))):
> M2:=factor(simplify(subs(ss,N2(R)))):
> ss1:={op(indets(M0)union indets(M1) union indets(M2)minus{s,t,R})=1};
> M0:=subs(ss1,M0);
> M1:=subs(ss1,M1);
> M2:=subs(ss1,M2);
> varJ:=[op(indets(subs(ss1,F))minus({s,t}))];
> GEJ:=factor(GaussianElimination(Jacobian(F, varJ)));
> return(Rank(GEJ));
> end:
> 
> 
> result:=fer(ii,x0);
                                  result := 3

> print(N,ii,x0,result);
                          54, [5, 3, 6], [5, 0, 0], 3

> 
> 
> quit
memory used=6.5MB, alloc=40.3MB, time=0.13
